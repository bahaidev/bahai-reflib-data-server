<fetch-select shadow>
  <select onchange={{change}}>
    <slot />
  </select>
</fetch-select>

<script type="module">

export default {
  props: {
    url: ''
  },
  setup (elem) {
    const update = async () => {
      const select = elem.shadowRoot.querySelector('select');

      const {url} = elem;

      let jsonOptions = [];
      if (!url) {
        return false;
      }
      try {
        const resp = await fetch(url);
        jsonOptions = await resp.json();
      } catch (err) {
        // eslint-disable-next-line no-console -- Debugging
        console.error('Erred fetching', err);
        // Continue so can trigger `missing-options` and show errors
        // return false;
      }

      if (!jsonOptions.length) {
        const ev = new Event('missing-options', {
          bubbles: true,
          // Get out of the shadow DOM
          composed: true
        });
        elem.dispatchEvent(ev);
        return false;
      }

      select.textContent = '';
      select.append(
        ...[...elem.querySelectorAll('option')].map((option) => {
          return option.cloneNode(true);
        }),
        ...jsonOptions.sort((a, b) => {
          // Sort so that an underdotted "H" is treated more like an "H"
          const form = 'NFD';
          const normA = (Array.isArray(a) ? a[1] : a).normalize(form);
          const normB = (Array.isArray(b) ? b[1] : b).normalize(form);
          return normA < normB ? -1 : normA > normB ? 1 : 0;
        }).map((jsonOption) => {
          const option = document.createElement('option');
          if (Array.isArray(jsonOption)) {
            option.value = jsonOption[0];
            option.textContent = jsonOption[1];
          } else {
            option.textContent = jsonOption;
          }
          return option;
        })
      );
      // console.log('json', jsonOptions, elem.outerHTML);

      return true;
    };

    elem.update = update;
    Object.defineProperty(elem, 'selectedOption', {
      get () {
        const select = elem.shadowRoot.querySelector('select');
        return select.options[select.selectedIndex];
      }
    });
    elem.connected = () => {
      // We apparently can't get our slots without shadow DOM, but they need
      //   copying too
      update();
    };
    return {
      change (e) {
        const ev = new Event('change', {
          bubbles: true,
          // Get out of the shadow DOM
          composed: true
        });
        elem.value = this.value;
        elem.dispatchEvent(ev);
      }
    };
  }
};
</script>
